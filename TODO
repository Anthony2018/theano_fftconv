TODO

- figure out how we can use cublasCgemmBatched for this instead (it's not in scikits.cuda but it should be easy to wrap)
    * will need to upgrade cuda for this, it's not in cuda 5.0 (but probably in 5.5 and 6.0). Wait for now.

- multistream does not seem to make any difference in performance (num_streams=1 and num_streams=32 perform the same)
    * get rid of multistream code

- optimise BatchedComplexDot, CuFFT and CuIFFT

- do some proper performance testing for different b, ic, oc, i0/i1, f0/f1 combinations, make some pretty graphs

- rescaling afterwards is also quite slow (I think Theano turns this into an elemwise div, even though I wrote it as a multiplication). Maybe this can be sped up as well.





- build a convop optimisation that replaces the convop with the fft-product-ifft sequence.




- previous attempt by Josh Bleecher Snyder using CuFFT directly: https://github.com/lumberlabs/fft_conv_op/blob/master/fft_conv_op.py
    * we can steal the optimisation code from this to use it as a basis.

- FFTs can probably be done 'in place' as well, this could be faster. To make this feasible in Theano, we'd need an FFTOp and an InPlaceFFTOp, where the latter gets swapped in by an optimisation whenever this is possible.
    * find out if scikits.cuda.fft.fft is destructive by default!




- we can just write an optimization that swaps the ConvOp for FFTGpuConv, like it currently swaps it for GpuConv, which is in turn a macro for GpuFFT+product+GpuIFFT. No need for gradients anywhere then!



process

    input:          (b, ic, i0, i1)                         float32
    filters:        (oc, ic, f0, f1)                        float32

    * pad filters
        filters:    (oc, ic, i0, i1)                        float32 # same size as input

    * reshape for FFT
        input:      (b * ic, i0, i1)                        float32
        filters:    (oc * ic, i0, i1)                       float32

    * perform FFT
        input:      (b * ic, i0, i1//2 + 1)                 complex64
        filters:    (oc * ic, i0, i1//2 + 1)                complex64

    * reshape again to unfold ic dimension, and to separate b and oc
        input:      (b, 1, ic, i0, i1//2 + 1)               complex64
        filters:    (1, oc, ic, i0, i1//2 + 1)              complex64

    * elementwise product
        output:     (b, oc, ic, i0, i1//2 + 1)              complex64

    * sum over the ic dimension (we can do this in the fourier domain because the FFT is linear)
        output:     (b, oc, i0, i1//2 + 1)                  complex64

    * reshape for IFFT
        output:     (b * oc, i0, i1//2 + 1)                 complex64

    * perform IFFT
        output:     (b * oc, i0, i1)                        float32

    * slice because the convolution was circular
        output:     (b * oc, i0 - f0 + 1, i1 - f1 + 1)      float32

    * reshape
        output:     (b, oc, i0 - f0 + 1, i1 - f1 + 1)       float32

        => result is a batched valid convolution of the input with the filters.




